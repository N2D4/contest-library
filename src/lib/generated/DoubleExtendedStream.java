/* Generated by Generificator from ExtendedStream.java */

package lib.generated;

import java.util.function.*;
import lib.generated.*;
import lib.utils.various.*;

import lib.generated.DoubleExtendedStream;
import lib.generated.IntExtendedStream;
import lib.generated.LongExtendedStream;
import lib.utils.Arr;
import lib.utils.tuples.Monad;

import java.util.*;
import java.util.function.*;
import java.util.stream.*;


public interface DoubleExtendedStream extends DoubleStream {

    @Override DoubleExtendedStream filter(DoublePredicate predicate);
    
    @Override DoubleExtendedStream map(DoubleUnaryOperator mapper);
    @Override <U> ExtendedStream<U> mapToObj(DoubleFunction<? extends U> mapper);
    @Override ExtendedStream<Double> boxed();
    
    /*IS-Int T./
    @Override DoubleExtendedStream asDoubleStream();
    @Override LongExtendedStream asLongStream();
    /.ELSE*/
    @Override IntExtendedStream mapToInt(DoubleToIntFunction mapper);
    /*END*/
    /*IS-Long T./
    @Override DoubleExtendedStream asDoubleStream();
    /.ELSE*/
    @Override LongExtendedStream mapToLong(DoubleToLongFunction mapper);
    /*END*/
    /*IS-Double double*/
    /*ELSE./
    @Override DoubleExtendedStream mapToDouble(DoubleUnaryOperator mapper);
    /.END*/
    
    @Override DoubleExtendedStream flatMap(DoubleFunction<? extends DoubleStream> mapper);
    
    @Override DoubleExtendedStream distinct();
    @Override DoubleExtendedStream sorted();
    
    
    @Override DoubleExtendedStream peek(DoubleConsumer action);
    @Override DoubleExtendedStream limit(long maxSize);
    @Override DoubleExtendedStream skip(long n);
    @Override void forEach(DoubleConsumer action);
    @Override void forEachOrdered(DoubleConsumer action);
    @Override double[] toArray();
    
    
    @Override double reduce(double identity, DoubleBinaryOperator accumulator);
    @Override OptionalDouble reduce(DoubleBinaryOperator accumulator);
    
    
    @Override <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner);
    
    
    
    @Override OptionalDouble min();
    @Override OptionalDouble max();
    
    @Override long count();
    @Override boolean anyMatch(DoublePredicate predicate);
    @Override boolean allMatch(DoublePredicate predicate);
    @Override boolean noneMatch(DoublePredicate predicate);
    @Override OptionalDouble findFirst();
    @Override OptionalDouble findAny();
    
    @Override PrimitiveIterator.OfDouble iterator();
    @Override Spliterator.OfDouble spliterator();
    
    @Override boolean isParallel();
    @Override DoubleExtendedStream sequential();
    @Override DoubleExtendedStream parallel();
    @Override DoubleExtendedStream unordered();
    @Override DoubleExtendedStream onClose(Runnable closeHandler);
    @Override void close();
    
    @Override double sum();
    @Override OptionalDouble average();
    @Override DoubleSummaryStatistics summaryStatistics();
    

    /**
     * Returns a parallel stream if parallel is true, or sequential if it's not.
     */
    default DoubleExtendedStream setParallel(boolean parallel) {
        if (parallel) {
            return parallel();
        } else {
            return sequential();
        }
    }


    /**
     * Returns this stream. Can be used to ensure that this stream is of type ExtendedStream at compile-time (useful for
     * code generators).
     */
    default DoubleExtendedStream ensureExtended() {
        return this;
    }


    static   DoubleExtendedStream ofStream(DoubleStream stream) {
        if (stream instanceof DoubleExtendedStream) return (DoubleExtendedStream) stream;
        return ofLazySpliterator(stream::spliterator, stream.isParallel()).onClose(stream::close);
    }

    static   DoubleExtendedStream ofLazySpliterator(Lazy<? extends Spliterator.OfDouble> spliterator, boolean parallel) {
        return new DoubleExtendedStreamImpl(spliterator, parallel);
    }
}
