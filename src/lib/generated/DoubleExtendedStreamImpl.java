/* Generated by Generificator on Thu Dec 19 21:12:39 CET 2019 from ExtendedStreamImpl.java */

package lib.generated;

import java.util.function.*;
import lib.generated.*;
import lib.utils.various.*;

import lib.generated.DoubleExtendedStream;
import lib.generated.IntExtendedStream;
import lib.generated.IntIntFunc;
import lib.generated.LongExtendedStream;
import lib.utils.Arr;
import lib.utils.Utils;
import lib.utils.function.Cons;
import lib.utils.function.Func;

import java.util.*;
import java.util.function.*;
import java.util.stream.*;


class DoubleExtendedStreamImpl implements DoubleExtendedStream {
    private final Lazy<? extends DoubleStream> lazyStream;
    private final boolean isStreamParallel;

    DoubleExtendedStreamImpl(Lazy<? extends DoubleStream> lazyStream, boolean isParallel) {
        this.lazyStream = lazyStream;
        this.isStreamParallel = isParallel;
    }



    private DoubleStream portStream(DoubleStream stream, DoubleStream from, boolean isParallel) {
        DoubleStream res = stream.onClose(from::close);
        res = isParallel ? res.parallel() : res.sequential();
        return res;
    }

    private DoubleExtendedStream arrOpF(Func<double[], double[]> serial, Func<double[], double[]> parallel, IntIntFunc characteristics) {
        return c(s -> {
            boolean isParallel = s.isParallel();
            Spliterator.OfDouble orig = s.spliterator();
            int charas = orig.characteristics();
            double[] arr = Utils.stream(orig).toArray();
            arr = (isParallel ? parallel : serial).apply(arr);
            Spliterator.OfDouble spliterator = Spliterators.spliterator(arr, Spliterator.ORDERED | Spliterator.IMMUTABLE | characteristics.apply(charas));
            return portStream(Utils.stream(spliterator), s, isParallel);
        });
    }

    private DoubleExtendedStream arrOpC(Cons<double[]> serial, Cons<double[]> parallel, IntIntFunc characteristics) {
        return arrOpF(a -> {
            serial.accept(a);
            return a;
        }, a -> {
            parallel.accept(a);
            return a;
        }, characteristics);
    }

    private DoubleStream getAndUpPort() {
        DoubleStream b = lazyStream.get();
        if (isParallel()) {
            return b.parallel();
        } else {
            return b.sequential();
        }
    }

    private Lazy<IntStream> li(Func<DoubleStream, IntStream> func) {
        return () -> func.apply(getAndUpPort());
    }

    private Lazy<LongStream> ll(Func<DoubleStream, LongStream> func) {
        return () -> func.apply(getAndUpPort());
    }

    private Lazy<DoubleStream> ld(Func<DoubleStream, DoubleStream> func) {
        return () -> func.apply(getAndUpPort());
    }

    private <U> Lazy<Stream<U>> lo(Func<DoubleStream, Stream<U>> func) {
        return () -> func.apply(getAndUpPort());
    }

    
    private Lazy<DoubleStream> l(Func<DoubleStream, DoubleStream> func) {
        return () -> func.apply(getAndUpPort());
    }

    private DoubleExtendedStreamImpl c(Func<DoubleStream, DoubleStream> func) {
        return c(func, isParallel());
    }

    private DoubleExtendedStreamImpl c(Func<DoubleStream, DoubleStream> func, boolean isParallel) {
        return new DoubleExtendedStreamImpl(l(func), isParallel);
    }
    

    private DoubleStream s() {
        return getAndUpPort();
    }





    @Override
    public DoubleExtendedStream filter(DoublePredicate predicate) {
        return c(s -> s.filter(predicate));
    }

    
    @Override
    public DoubleExtendedStream map(DoubleUnaryOperator mapper) {
        return c(s -> s.map(mapper));
    }

    @Override
    public <U> ExtendedStream<U> mapToObj(DoubleFunction<? extends U> mapper) {
        return ExtendedStream.ofLazyStream(lo(s -> s.mapToObj(mapper)), isParallel());
    }

    @Override
    public ExtendedStream<Double> boxed() {
        return ExtendedStream.ofLazyStream(lo(s -> s.boxed()), isParallel());
    }
    

    /*IS-Int T./
    @Override
    public DoubleExtendedStream asDoubleStream() {
        return DoubleExtendedStream.ofLazyStream(ld(s -> s.asDoubleStream()), isParallel());
    }

    @Override
    public LongExtendedStream asLongStream() {
        return LongExtendedStream.ofLazyStream(ll(s -> s.asLongStream()), isParallel());
    }
    /.ELSE*/
    @Override
    public IntExtendedStream mapToInt(DoubleToIntFunction mapper) {
        return IntExtendedStream.ofLazyStream(li(s -> s.mapToInt(mapper)), isParallel());
    }
    /*END*/

    /*IS-Long T./
    @Override
    public DoubleExtendedStream asDoubleStream() {
        return DoubleExtendedStream.ofLazyStream(ld(s -> s.asDoubleStream()), isParallel());
    }
    /.ELSE*/
    @Override
    public LongExtendedStream mapToLong(DoubleToLongFunction mapper) {
        return LongExtendedStream.ofLazyStream(ll(s -> s.mapToLong(mapper)), isParallel());
    }
    /*END*/

    /*IS-Double double*/
    /*ELSE./
    @Override
    public DoubleExtendedStream mapToDouble(DoubleUnaryOperator mapper) {
        return DoubleExtendedStream.ofLazyStream(ld(s -> s.mapToDouble(mapper)), isParallel());
    }
    /.END*/

    
    @Override
    public DoubleExtendedStream flatMap(DoubleFunction<? extends DoubleStream> mapper) {
        return c(s -> s.flatMap(mapper));
    }
    

    @Override
    public DoubleExtendedStream distinct() {
        return c(DoubleStream::distinct);
    }

    
    @Override
    public DoubleExtendedStream sorted() {
        return arrOpC(Arr::sort, Arr::parallelSort, c -> c | Spliterator.SORTED);
    }
    

    @Override
    public DoubleExtendedStream peek(DoubleConsumer action) {
        return c(s -> s.peek(action));
    }

    @Override
    public DoubleExtendedStream limit(long maxSize) {
        return c(s -> s.limit(maxSize));
    }

    @Override
    public DoubleExtendedStream skip(long n) {
        return c(s -> s.skip(n));
    }

    @Override
    public void forEach(DoubleConsumer action) {
        s().forEach(action);
    }

    @Override
    public void forEachOrdered(DoubleConsumer action) {
        s().forEachOrdered(action);
    }

    @Override
    public double[] toArray() {
        return s().toArray();
    }

    
    

    @Override
    public double reduce(double identity, DoubleBinaryOperator accumulator) {
        return s().reduce(identity, accumulator);
    }

    @Override
    public OptionalDouble reduce(DoubleBinaryOperator accumulator) {
        return s().reduce(accumulator);
    }

    
    

    @Override
    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
        return s().collect(supplier, accumulator, combiner);
    }

    
    

    
    @Override
    public OptionalDouble min() {
        return s().min();
    }

    @Override
    public OptionalDouble max() {
        return s().max();
    }
    

    @Override
    public long count() {
        return s().count();
    }

    @Override
    public boolean anyMatch(DoublePredicate predicate) {
        return s().anyMatch(predicate);
    }

    @Override
    public boolean allMatch(DoublePredicate predicate) {
        return s().allMatch(predicate);
    }

    @Override
    public boolean noneMatch(DoublePredicate predicate) {
        return s().noneMatch(predicate);
    }

    @Override
    public OptionalDouble findFirst() {
        return s().findFirst();
    }

    @Override
    public OptionalDouble findAny() {
        return s().findAny();
    }

    
    @Override
    public PrimitiveIterator.OfDouble iterator() {
        return s().iterator();
    }

    @Override
    public Spliterator.OfDouble spliterator() {
        return s().spliterator();
    }
    

    @Override
    public boolean isParallel() {
        return isStreamParallel;
    }

    @Override
    public DoubleExtendedStream sequential() {
        return c(a -> a, false);
    }

    @Override
    public DoubleExtendedStream parallel() {
        return c(a -> a, true);
    }

    @Override
    public DoubleExtendedStream unordered() {
        return c(DoubleStream::unordered);
    }

    @Override
    public DoubleExtendedStream onClose(Runnable closeHandler) {
        return c(s -> s.onClose(closeHandler));
    }

    @Override
    public void close() {
        s().close();
    }

    
    @Override
    public double sum() {
        return s().sum();
    }

    @Override
    public OptionalDouble average() {
        return s().average();
    }

    @Override
    public DoubleSummaryStatistics summaryStatistics() {
        return s().summaryStatistics();
    }
    
}
